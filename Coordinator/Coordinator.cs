//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1378
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;
using System;
using System.Threading;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using W3C.Soap;
using coord = Robotics.CoroBot.Coordinator;
using image = Robotics.CoroBot.ImageProcessor.Proxy;
using motion = Robotics.CoroBot.MotionController.Proxy;
using System.Drawing;
using Microsoft.Ccr.Adapters.WinForms;


namespace Robotics.CoroBot.Coordinator
{


    /// <summary>
    /// Implementation class for Coordinator
    /// </summary>
    [DisplayName("Coordinator")]
    [Description("The Coordinator Service")]
    [Contract(Contract.Identifier)]
    public class CoordinatorService : DsspServiceBase
    {
        public enum States { Idle, Lost };

        public States state = States.Idle;
        public bool ready = false;
        public float driveForwardDistance = .5F;
        public image.ImageProcessorResult imageResult = null;
        CoordinatorForm form = null;
        List<FoundFolder> visitedFolders = new List<FoundFolder>();
        List<Coordinate> possibleLocations;

        /// <summary>
        /// _state
        /// </summary>
        private CoordinatorState _state = new CoordinatorState();

        /// <summary>
        /// _main Port
        /// </summary>
        [ServicePort("/coordinator", AllowMultipleInstances = false)]
        private CoordinatorOperations _mainPort = new CoordinatorOperations();

        [Partner("Image", Contract = image.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExisting, Optional = false)]
        private image.ImageProcessorOperations _imagePort = new image.ImageProcessorOperations();

        [Partner("Motion", Contract = motion.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExisting, Optional = false)]
        private motion.MotionControllerOperations _drivePort = new motion.MotionControllerOperations();

        /// <summary>
        /// Default Service Constructor
        /// </summary>
        public CoordinatorService(DsspServiceCreationPort creationPort)
            :
                base(creationPort)
        {
        }

        /// <summary>
        /// Service Start
        /// </summary>
        protected override void Start()
        {
            base.Start();
            // Add service specific initialization here.
            WinFormsServicePort.Post(new RunForm(CreateForm));
        }

        private System.Windows.Forms.Form CreateForm()
        {
            form = new CoordinatorForm(_mainPort);
            return form;
        }

        private void Begin()
        {
            state = States.Lost;
            FoundFolder largestFolder = FindLargestFolder();

            Console.WriteLine("Result of turning is " + TurnToFolder(largestFolder));

            //!!We have not checked for null
            visitedFolders.Add(largestFolder);
            CenterToFolder();
            DriveToFolder();
            //Drive back so we can do another 360
            Console.WriteLine("Going backward");
            DriveForward(-.5F);
            FoundFolder secondLargest = TurnToSecondLargestFolder();
            //!!We have not checked for null
            visitedFolders.Add(secondLargest);
            possibleLocations = Localize();
        }



        public void GetImage()
        {
            ready = false;
            Activate(Arbiter.Choice(_imagePort.Get(new GetRequestType()),
                delegate(image.ImageProcessorResult result)
                {
                    ready = true;
                    imageResult = result;
                },
                delegate(Fault f) { LogError(f); }
            ));
            while (!ready)
            {
                Thread.Sleep(1000);
            }
        }

        public void TurnRight(int degrees)
        {
            ready = false;
            motion.TurnRequest req = new motion.TurnRequest();
            req.Radians = -degrees * Math.PI / 180;
            Activate(Arbiter.Choice(_drivePort.Turn(req),
                delegate(DefaultUpdateResponseType result) { ready = true; },
                delegate(Fault f) { LogError(f); }
            ));
            while (!ready)
            {
                Thread.Sleep(1000);
            }
        }

        public void TurnLeft(int degrees)
        {
            ready = false;
            motion.TurnRequest req = new motion.TurnRequest();
            req.Radians = degrees * Math.PI / 180;
            Activate(Arbiter.Choice(_drivePort.Turn(req),
                delegate(DefaultUpdateResponseType result) { ready = true; },
                delegate(Fault f) { LogError(f); }
            ));
            while (!ready)
            {
                Thread.Sleep(1000);
            }
        }

        public bool DriveForward(float meters)
        {
            ready = false;
            bool completed = true;
            motion.DriveRequest req = new motion.DriveRequest();
            req.Distance = meters;
            Activate(Arbiter.Choice(_drivePort.Drive(req),
                delegate(DefaultUpdateResponseType result) { ready = true; },
                delegate(Fault f) { completed = false; ready = true;  }
            ));
            while (!ready)
            {
                Console.WriteLine("Sleeping");
                Thread.Sleep(1000);
            }
            return completed;
        }

        public void StartWaypoints(Coordinate previous, Coordinate current)
        {
            PointF dest = null;

            // From the current, determine if we're in corridor 1 or 2
            if (current.X >= 20.2)
            {
                // Corridor 1
                dest = new PointF(21, (float)current.Y);

            }
            else
            {
                dest = new PointF((float)current.X, 3);
            }

        }

        public void DriveToFolder(){
            int driveCount = 0;
            while (true)
            {
                Console.WriteLine("Driving to folder");
                //If Drive returns false then stop driving forward
                if (!DriveForward(driveForwardDistance))
                {
                    Console.WriteLine("Stopping b/c drive forward returned false");
                    break;
                }
                driveCount++;
                //If you move several times then increase travel distance..
                //..Before centering again
                if (driveCount >= 3)
                {
                    Console.WriteLine("Increasing travel distance");
                    driveForwardDistance = 1;
                }
                Console.WriteLine("Centering folder in drive");
                CenterToFolder();
            }
        }

        public image.Folder CenterToFolder()
        {
            //Return the Folder if  robot is +- OffsetThreshold degrees 
            //from the center of the folder
            Console.WriteLine("Centering to folder");
            int OffsetThreshold = 3;
            GetImage();
            if (imageResult.Folders.Count > 0)
            {
                image.Folder bestFolder = imageResult.Folders[0];
                int bestOffset = GetHeadingOffset((int)imageResult.Folders[0].X);
                foreach (image.Folder f in imageResult.Folders)
                {
                    if (Math.Abs(GetHeadingOffset((int)f.X)) < Math.Abs(bestOffset))
                    {
                        bestFolder = f;
                        bestOffset = GetHeadingOffset((int)f.X);
                    }
                }
                //If Done
                if (Math.Abs(bestOffset) <= OffsetThreshold)
                {
                    Console.WriteLine("Centered");
                    return bestFolder;
                }
                //Otherwise Turn and try again
                if (bestOffset < 0)
                {
                    Console.WriteLine("Turning right");
                    TurnRight(Math.Abs(bestOffset));
                    return CenterToFolder();
                }
                else
                {
                    Console.WriteLine("Turning left");
                    TurnLeft(Math.Abs(bestOffset));
                    return CenterToFolder();
                }
            }
            //I didn't find any folders
            else
            {
                return null;
            }
        }

        public void DriveToPoint(Point start, Point end)
        {

        }
        private FoundFolder TurnToSecondLargestFolder()
        {
            List<FoundFolder> folders = new List<FoundFolder>();
            int numTurns = 9;
            int degPerTurn = 360 / numTurns;
            int lastFolderHeading = -1000;
            for (int i = 0; i < numTurns; i++)
            {
                GetImage();
                foreach (image.Folder f in imageResult.Folders)
                {
                    FoundFolder ff = new FoundFolder();
                    ff.Color = f.Color;
                    ff.Heading = i * degPerTurn + GetHeadingOffset((int)f.X);
                    ff.Size = f.Area;
                    if (Math.Abs(ff.Heading - lastFolderHeading) < 15)
                    {
                        folders.Add(ff);
                    }
                }
                TurnRight(degPerTurn);
            }
            if (folders.Count > 0)
            {
                FoundFolder largestFolder = folders[0];
                FoundFolder secondLargest = null;
                if (folders.Count > 1)
                {
                    secondLargest = folders[0];
                }
                foreach (FoundFolder f in folders)
                {
                    if (f.Size > largestFolder.Size)
                    {
                        secondLargest = largestFolder;
                        largestFolder = f;                        
                    }
                }
                TurnLeft(360 - largestFolder.Heading);
                return secondLargest;
            }
            return null;
        }

        private bool TurnToFolder(FoundFolder target)
        {
            int numTurns = 9;
            int degPerTurn = 360 / numTurns;
            int lastFolderHeading = -1000;
            for (int i = 0; i < numTurns; i++)
            {
                LogInfo("Sending Image request.");
                GetImage();
                LogInfo("Received Image.");
                foreach (image.Folder f in imageResult.Folders)
                {
                    Console.WriteLine("Looking for target folder: " + target.Color + ", " + target.Size);
                    if (f.Color == target.Color) {
                        Console.WriteLine("Target size is " + target.Size + ", looking at size of " + f.Area);
                        if (Math.Abs(f.Area - target.Size) <= 1000)
                        {
                            // We've found the right target
                            return true;
                        }
                    }                    
                }
                Console.WriteLine("Looking for target, turning right " + degPerTurn);
                TurnRight(degPerTurn);
            }
            Console.WriteLine("Target not found");
            return false;
        }

        private FoundFolder FindLargestFolder()
        {
            List<FoundFolder> folders = new List<FoundFolder>();
            int numTurns = 9;
            int degPerTurn = 360 / numTurns;
            int lastFolderHeading = -1000;
            for (int i = 0; i < numTurns; i++)
            {
                LogInfo("Sending Image request.");
                GetImage();
                LogInfo("Received Image.");
                foreach (image.Folder f in imageResult.Folders)
                {
                    Console.WriteLine("Checking for folders");
                    FoundFolder ff = new FoundFolder();
                    ff.Color = f.Color;
                    ff.Heading = i * degPerTurn + GetHeadingOffset((int)f.X);
                    ff.Size = f.Area;
                    //if (Math.Abs(ff.Heading - lastFolderHeading) < 15)
                    //{
                    //    folders.Add(ff);
                    //}

                    folders.Add(ff);
                }
                LogInfo("Send Turn RIght.");
                TurnRight(degPerTurn);
                LogInfo("Received TurnRight");
            }
            if (folders.Count > 0)
            {
                FoundFolder largestFolder = folders[0];
                foreach (FoundFolder f in folders)
                {
                    if (f.Size > largestFolder.Size)
                    {
                        largestFolder = f;
                    }
                }
                Console.WriteLine("Turning to largest folder, heading is " + largestFolder.Heading);
                //TurnLeft(360 - largestFolder.Heading);
                return largestFolder;
                
            }

            Console.WriteLine("No largest folder found");
            return null;
        }

        public int GetHeadingOffset(int X)
        {
            return -(((X - 320) * 20) / 320);
        }

        public class FoundFolder
        {
            public string Color;
            public int Heading;
            public int Size;
        }

        public class Coordinate
        {
            public double X;
            public double Y;
            public string Color;

            public Coordinate(double x, double y, char c)
            {
                X = x;
                Y = y;
                if (c == 'R') Color = "Red";
                if (c == 'G') Color = "Green";
                if (c == 'Y') Color = "Yellow";
            }
        }

        public void buildZigZag(List<Coordinate> frontZigZag1, List<Coordinate> frontZigZag2)
        {
            Coordinate s1 = new Coordinate(20.2, 21.56, 'R');
            frontZigZag1.Add(s1);

            Coordinate s2 = new Coordinate(22.4, 21.66, 'Y');
            frontZigZag1.Add(s2);


            Coordinate s3 = new Coordinate(20.2, 19.45, 'G');
            frontZigZag1.Add(s3);

            Coordinate s4 = new Coordinate(22.4, 17.4, 'Y');
            frontZigZag1.Add(s4);

            Coordinate s5 = new Coordinate(20.2, 16.63, 'R');
            frontZigZag1.Add(s5);

            Coordinate s6 = new Coordinate(22.4, 14.65, 'G');
            frontZigZag1.Add(s6);

            Coordinate s7 = new Coordinate(20.2, 12.47, 'Y');
            frontZigZag1.Add(s7);

            Coordinate s8 = new Coordinate(21.8, 10.2, 'R');
            frontZigZag1.Add(s8);

            Coordinate s9 = new Coordinate(20.2, 9.67, 'R');
            frontZigZag1.Add(s9);

            Coordinate s10 = new Coordinate(22.4, 7.1, 'Y');
            frontZigZag1.Add(s10);

            Coordinate s11 = new Coordinate(20.2, 6.72, 'G');
            frontZigZag1.Add(s11);

            Coordinate s12 = new Coordinate(22.4, 4.3, 'R');
            frontZigZag1.Add(s12);

            Coordinate s13 = new Coordinate(20.2, 4.4, 'Y');
            frontZigZag1.Add(s13);

            //second list starting

            Coordinate s14 = new Coordinate(18.97, 2, 'G');
            frontZigZag2.Add(s14);

            Coordinate s15 = new Coordinate(16.49, 4.25, 'G');
            frontZigZag2.Add(s15);

            Coordinate s16 = new Coordinate(15.96, 2, 'R');
            frontZigZag2.Add(s16);

            Coordinate s17 = new Coordinate(13.4, 4.25, 'R');
            frontZigZag2.Add(s17);

            Coordinate s18 = new Coordinate(13.02, 2, 'Y');
            frontZigZag2.Add(s18);

            Coordinate s19 = new Coordinate(10.54, 4.25, 'Y');
            frontZigZag2.Add(s19);

            Coordinate s20 = new Coordinate(9.91, 2, 'G');
            frontZigZag2.Add(s20);


            Coordinate s21 = new Coordinate(7.49, 4.25, 'R');
            frontZigZag2.Add(s21);


            Coordinate s22 = new Coordinate(6.42, 2, 'G');
            frontZigZag2.Add(s22);


            Coordinate s23 = new Coordinate(5.42, 4.25, 'G');
            frontZigZag2.Add(s23);
        }



        public List<Coordinate> Localize()
        {
            List<char> v = new List<char>();
            foreach (FoundFolder f in visitedFolders)
            {
                if (f.Color == "Red") v.Add('R');
                if (f.Color == "Green") v.Add('G');
                if (f.Color == "Yellow") v.Add('Y');
            }

            List<Coordinate> result = new List<Coordinate>();

            //build the two main zig zag sequences
            List<Coordinate> frontZigZag1 = new List<Coordinate>();
            List<Coordinate> frontZigZag2 = new List<Coordinate>();
            List<Coordinate> backZigZag1 = new List<Coordinate>();
            List<Coordinate> backZigZag2 = new List<Coordinate>();


            buildZigZag(frontZigZag1, frontZigZag2);

            backZigZag1.AddRange(frontZigZag1);
            backZigZag2.AddRange(frontZigZag2);

            backZigZag1.Reverse();
            backZigZag2.Reverse();



            List<int> res1 = match(frontZigZag1, v);

            for (int x = 0; x < res1.Count; x++)
            {
                result.Add(frontZigZag1[res1[x]]);
            }

            res1 = match(frontZigZag2, v);

            for (int x = 0; x < res1.Count; x++)
            {
                result.Add(frontZigZag2[res1[x]]);
            }

            res1 = match(backZigZag1, v);

            for (int x = 0; x < res1.Count; x++)
            {
                result.Add(backZigZag1[res1[x]]);
            }

            res1 = match(backZigZag2, v);

            for (int x = 0; x < res1.Count; x++)
            {
                result.Add(backZigZag2[res1[x]]);
            }
            return result;

        }

        public List<int> match(List<Coordinate> list, List<char> visited)
        {
            List<int> result = new List<int>();


            int listSize = list.Count;
            int visitedSize = visited.Count;


            String listS = "";

            for (int x = 0; x < listSize; x++)
            {
                listS += list[x].Color;
            }


            String listV = "";

            for (int x = 0; x < visitedSize; x++)
            {
                listV += visited[x];
            }

            //keep polling for other match conditions
            int ctr = 0;

            while (listS.Contains(listV))
            {

                Console.WriteLine(listS);
                Console.WriteLine(ctr);

                result.Add(ctr + listV.Length - 1 + listS.IndexOf(listV));

                ctr += listS.Substring(0, listV.Length + listS.IndexOf(listV)).Length;

                listS = listS.Substring(listV.Length + listS.IndexOf(listV));

            }



            return result;
        }


        /// <summary>
        /// Get Handler
        /// </summary>
        /// <param name="get"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetHandler(Get get)
        {
            Begin();
            get.ResponsePort.Post(_state);
            yield break;
        }
    }
}
