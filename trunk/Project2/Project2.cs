//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using W3C.Soap;
using project2 = Robotics.Project2;

using cbir = CoroWare.Robotics.Services.CoroBotIR.Proxy;

using blob = Microsoft.Robotics.Services.Sample.BlobTracker.Proxy;

using motioncontroller = Robotics.CoroBot.MotionController;
using cbdrive = CoroWare.Robotics.Services.CoroBotDrive.Proxy;
using System.IO;
using System.Net;
using Robotics.CoroBot.MotionController;

namespace Robotics.Project2
{
    
    
    /// <summary>
    /// Implementation class for Project2
    /// </summary>
    [DisplayName("Project2")]
    [Description("Service for CS 3630 project 2")]
    [Contract(Contract.Identifier)]
    public class Project2Service : DsspServiceBase
    {
        
        /// <summary>
        /// _state
        /// </summary>
        private Project2State _state = new Project2State();
        
        /// <summary>
        /// _main Port
        /// </summary>
        [ServicePort("/project2", AllowMultipleInstances=false)]
        private Project2Operations _mainPort = new Project2Operations();

        // Partner with blob tracker
        [Partner("BlobTracker", Contract = blob.Contract.Identifier,
                CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        blob.BlobTrackerOperations _blobPort = new blob.BlobTrackerOperations();
        blob.BlobTrackerOperations _blobNotify = new blob.BlobTrackerOperations();

        // Partner with motion controller
        //[Partner("MotionController", Contract = motioncontroller.Contract.Identifier,
        //        CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        //motioncontroller.MotionControllerOperations _motionPort = new motioncontroller.MotionControllerOperations();

        // Partner with driver
        [Partner("drive", Contract = cbdrive.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExisting)]
        private cbdrive.CoroBotDriveOperations _drivePort = new cbdrive.CoroBotDriveOperations();

        // IR
        //[Partner("corobotir", Contract = cbir.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExisting)]
        //cbir.CoroBotIROperations _irPort = new cbir.CoroBotIROperations();

        private const double MOTOR_POWER = 0.6;
        // Positive is counter-clockwise
        private const double MIN_TURN_AMOUNT = 25;
        private const double INITIAL_TURN_AMOUNT = 90;

        /// <summary>
        /// The number of degrees the robot last rotated.
        /// </summary>
        private double lastRotation = 0;

        private double turnAmountInDegrees = INITIAL_TURN_AMOUNT;


        /// <summary>
        /// Default Service Constructor
        /// </summary>
        public Project2Service(DsspServiceCreationPort creationPort) : 
                base(creationPort)
        {
        }
        
        /// <summary>
        /// Service Start
        /// </summary>
        protected override void Start()
        {
			base.Start();
			// Add service specific initialization here.

            _blobPort.Subscribe(_blobNotify);

            Activate<ITask>(Arbiter.Receive<blob.ImageProcessed>(true, _blobNotify, OnImageProcessed));

            //Console.WriteLine(_irPort.Get());

            //Activate(Arbiter.Choice(_irPort.Get(),
            //    delegate( success) { },
            //    delegate(Fault f) { LogError(f); }
            //));
        }

        void OnImageProcessed(blob.ImageProcessed imageProcessed)
        {
            Console.WriteLine("Project 2 received ImageProcessed signal");

            if (imageProcessed.Body.Results.Count > 0)
            {

                // Display results for each blob found
                for (int i = 0; i < imageProcessed.Body.Results.Count; i++)
                {
                    blob.FoundBlob foundBlob = imageProcessed.Body.Results[i];

                    if (foundBlob.Area > 100) //object detected
                    {

                        Console.WriteLine("Blob detected at (" + foundBlob.MeanX + "," + foundBlob.MeanY + ")");
                        this.MakeDecision(foundBlob);
                    }
                    else
                    {
                        Console.WriteLine("Blob is too small: area=" + foundBlob.Area);
                    }
                }
            }
        }

        double GetFakeIRDistance()
        {
            double distance = 0;

            //String file = @"C:\Documents and Settings\JL\Desktop\corobotir.htm";

            String robotIP = "128.61.22.166";

            WebClient client = new WebClient();
            String url = @"http://" + robotIP + @":50000/corobotir";

            //using (StreamReader reader = new StreamReader(file))
            using (StreamReader reader = new StreamReader(client.OpenRead(new Uri(url))))
            {
                String line;
                while ((line = reader.ReadLine()) != null)
                {
                    // Looking for <LastFrontRange>25.4</LastFrontRange>
                    // or <th>Front (Meters):</th><td>25.4</td>

                    //String startText = @"<th>Front (Meters):</th><td>";
                    //String endText = "</td>";

                    String startText = @"<LastFrontRange>";
                    String endText = "</LastFrontRange>";

                    int start = line.IndexOf(startText);

                    if (start >= 0)
                    {
                        int end = line.IndexOf(endText, start);

                        if (end >= start)
                        {
                            try
                            {
                                String result = line.Substring(start + startText.Length,
                                    end - start - startText.Length);

                                distance = double.Parse(result);
                            }
                            catch (ArgumentOutOfRangeException aoore)
                            {
                                Console.WriteLine(aoore.Message + System.Environment.NewLine +
                                    aoore.StackTrace);
                            }
                        }
                    }

                }
            }

            return distance;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="lastRotation"></param>
        /// <returns></returns>
        double adjustTurningDistance(double lastRotation)
        {
            double result = Math.Abs(lastRotation) - 2;

            if (result < MIN_TURN_AMOUNT)
            {
                result = MIN_TURN_AMOUNT;
            }

            return result;
        }

        void MakeDecision(blob.FoundBlob foundBlob)
        {
            int meanX = (int)(foundBlob.MeanX);

            double irDistance = this.GetFakeIRDistance();

            Console.WriteLine("Distance is " + irDistance);

            if (true)
                return;

	        if (irDistance <= .6)
            {
                // We are in IR Sensor range
                if (irDistance <= .1)
                { 
			        return; // We win!
		        }
		        else if (irDistance > .3) {
                    _motionPort.Post(new Drive(new DriveRequest(0.15, MOTOR_POWER)));
			        //driveforward(.5 ft);
		        }
		        else {
                    _motionPort.Post(new Drive(new DriveRequest(0.07, MOTOR_POWER)));
			        //driveforward(.25 ft); // We are 1 ft away move slowly
		        }
        			
	        }
	        else
            {
                // We need to go off of vision
	            int center = 295;
                int buffer = 5;

	            if ((meanX >= center - buffer)  && (meanX <= center + buffer))
                {
		            //driveforward(.5 ft);
                    _motionPort.Post(new Drive(new DriveRequest(0.15, MOTOR_POWER)));

                    // If we moved forward, there was no turn, so reset the turning amount
                    turnAmountInDegrees = INITIAL_TURN_AMOUNT;
                    lastRotation = 0;
	            }
	            else if (meanX > center)
                {
                    // Turn right

                    // Find out whether we were previously turning left. If so, we turned too far
                    // and should reduce the turn amount.
                    if (lastRotation > 0)
                    {
                        turnAmountInDegrees = adjustTurningDistance(lastRotation);                        
                    }

                    // Turning right means make it negative

                    double radians = turnAmountInDegrees * Math.PI / 180 * -1;
                    _motionPort.Post(new Turn(new TurnRequest(radians, MOTOR_POWER)));

                    lastRotation = turnAmountInDegrees * -1;
	            }
                else
                {
                    // Turn left

                    // Find out whether we were previously turning right. If so, we turned too far
                    // and should reduce the turn amount.
                    if (lastRotation < 0)
                    {
                        turnAmountInDegrees = adjustTurningDistance(lastRotation);
                    }

                    double radians = turnAmountInDegrees * Math.PI / 180;
                    _motionPort.Post(new Turn(new TurnRequest(radians, MOTOR_POWER)));

                    lastRotation = turnAmountInDegrees;
                }
            }

        }

        #region UNUSED
        /// <summary>
        /// Get Handler
        /// </summary>
        /// <param name="get"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetHandler(Get get)
        {
            get.ResponsePort.Post(_state);
            yield break;
        }

        #endregion
    }
}
