//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using W3C.Soap;
using project2 = Robotics.Project2;

using cbir = CoroWare.Robotics.Services.CoroBotIR.Proxy;

using blob = Microsoft.Robotics.Services.Sample.BlobTracker.Proxy;

using motioncontroller = Robotics.CoroBot.MotionController;
using cbdrive = CoroWare.Robotics.Services.CoroBotDrive.Proxy;
using System.IO;
using System.Net;
using Robotics.CoroBot.MotionController;
using System.Timers;

namespace Robotics.Project2
{
    
    
    /// <summary>
    /// Implementation class for Project2
    /// </summary>
    [DisplayName("Project2")]
    [Description("Service for CS 3630 project 2")]
    [Contract(Contract.Identifier)]
    public class Project2Service : DsspServiceBase
    {
        
        /// <summary>
        /// _state
        /// </summary>
        private Project2State _state = new Project2State();
        
        /// <summary>
        /// _main Port
        /// </summary>
        [ServicePort("/project2", AllowMultipleInstances=false)]
        private Project2Operations _mainPort = new Project2Operations();

        // Partner with blob tracker
        [Partner("BlobTracker", Contract = blob.Contract.Identifier,
                CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        blob.BlobTrackerOperations _blobPort = new blob.BlobTrackerOperations();
        blob.BlobTrackerOperations _blobNotify = new blob.BlobTrackerOperations();

        // Partner with motion controller
        [Partner("MotionController", Contract = motioncontroller.Contract.Identifier,
                CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        motioncontroller.MotionControllerOperations _motionPort = new motioncontroller.MotionControllerOperations();

        // Partner with driver
        [Partner("drive", Contract = cbdrive.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExisting)]
        private cbdrive.CoroBotDriveOperations _drivePort = new cbdrive.CoroBotDriveOperations();

        // IR
        //[Partner("corobotir", Contract = cbir.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExisting)]
        //cbir.CoroBotIROperations _irPort = new cbir.CoroBotIROperations();

        private const double MOTOR_POWER = 0.6;
        // Positive is counter-clockwise
        private const double MIN_TURN_AMOUNT = 25;
        private const double INITIAL_TURN_AMOUNT = 90;

        private const double SWITCH_TO_IR_DISTANCE = 0.6;

        /// <summary>
        /// The number of degrees the robot last rotated.
        /// </summary>
        private double lastRotation = 0;

        private double turnAmountInDegrees = INITIAL_TURN_AMOUNT;

        private System.Timers.Timer imageTimer;
        private System.Timers.Timer irTimer;
        private System.Timers.Timer stopTimer;

        private Boolean hasStarted = false;

        /// <summary>
        /// Default Service Constructor
        /// </summary>
        public Project2Service(DsspServiceCreationPort creationPort) : 
                base(creationPort)
        {
            imageTimer = new System.Timers.Timer();
            irTimer = new System.Timers.Timer();
            stopTimer = new System.Timers.Timer();
        }
        
        /// <summary>
        /// Service Start
        /// </summary>
        protected override void Start()
        {
			base.Start();
			// Add service specific initialization here.

            //_blobPort.Subscribe(_blobNotify);

            //Activate<ITask>(Arbiter.Receive<blob.ImageProcessed>(true, _blobNotify, OnImageProcessed));

            //Console.WriteLine(_irPort.Get());

            //Activate(Arbiter.Choice(_irPort.Get(),
            //    delegate( success) { },
            //    delegate(Fault f) { LogError(f); }
            //));

            imageTimer.Elapsed += new ElapsedEventHandler(OnTimedEvent);

            imageTimer.Interval = 3000;
            imageTimer.Enabled = true;

            irTimer.Elapsed += new ElapsedEventHandler(OnIRTimedEvent);

            irTimer.Interval = 4000;
            irTimer.Enabled = false;

            stopTimer.Elapsed += new ElapsedEventHandler(OnStopTimedEvent);
            stopTimer.Enabled = false;
            
        }

        private void OnStopTimedEvent(object source, ElapsedEventArgs e)
        {
            SendStopMessage();
        }

        private void OnIRTimedEvent(object source, ElapsedEventArgs e)
        {
            irMode();
        }

        private void OnTimedEvent(object source, ElapsedEventArgs e)
        {
            GetNewImage();
        }

        void GetNewImage()
        {
            Activate(Arbiter.Choice(_blobPort.Get(),
                ProcessImage, delegate(Fault f) { LogInfo("Error on Get"); }));
        }

        private void SendStopMessage()
        {
            cbdrive.CoroBotDriveState newState = new cbdrive.CoroBotDriveState();
            newState.InSequenceNumber = 0;
            newState.DriveEnable = false;
            
            Console.WriteLine("Sending stop message");

            Activate(Arbiter.Choice(_drivePort.Replace(newState),
                delegate(DefaultReplaceResponseType success) { },
                delegate(Fault f) { LogError(f); }
            ));
        }

        private void SendDriveForwardMessage(double rotation, double translation)
        {
            cbdrive.CoroBotDriveState newState = new cbdrive.CoroBotDriveState();
            newState.InSequenceNumber = 0;
            newState.DriveEnable = true;

            double rotationClip = 0.8;

            if (rotation > rotationClip)
            {
                rotation = rotationClip;
            }
            else if (rotation < -1*rotationClip)
            {
                rotation = -1*rotationClip;
            }

            if (translation > 1)
            {
                translation = 1;
            }
            else if (translation < -1)
            {
                translation = -1;
            }


            newState.Rotation = rotation;
            newState.Translation = translation;

            Console.WriteLine("Turning with rotation " + rotation + " and translation " + translation);

            Activate(Arbiter.Choice(_drivePort.Replace(newState),
                delegate(DefaultReplaceResponseType success) { },
                delegate(Fault f) { LogError(f); }
            ));
        }

        void SwitchToIRMode()
        {
            imageTimer.Enabled = false;
            irTimer.Enabled = true;

            Console.WriteLine("Robot is in IR mode");
        }

        void SwitchToVisionMode()
        {
            irTimer.Enabled = false;
            imageTimer.Enabled = true;

            Console.WriteLine("Robot is in vision mode");
        }

        void ProcessImage(blob.BlobTrackerState state)
        {
            Console.WriteLine("Project 2 is in ProcessImage");

            if (state.Results.Count > 0)
            {

                // Display results for each blob found
                for (int i = 0; i < state.Results.Count; i++)
                {
                    blob.FoundBlob foundBlob = state.Results[i];

                    if (foundBlob.Area > 100) //object detected
                    {

                        hasStarted = true;

                        Console.WriteLine("Blob detected at (" + foundBlob.MeanX + "," + foundBlob.MeanY + ")");
                        this.visionMode(foundBlob);
                    }
                    else
                    {
                        Console.WriteLine("Blob is too small: area=" + foundBlob.Area);

                        if (hasStarted)
                        {
                            Console.WriteLine("Blob too small, robot is switching to IR mode");
                            SwitchToIRMode();
                        }
                    }
                }
            }
            else
            {
                Console.WriteLine("No blobs to process");

                if (hasStarted)
                {
                    Console.WriteLine("No blobs found, robot is switching to IR mode");
                    SwitchToIRMode();
                }
            }

        }

        void OnImageProcessed(blob.ImageProcessed imageProcessed)
        {
            Console.WriteLine("Project 2 received ImageProcessed signal");

            if (imageProcessed.Body.Results.Count > 0)
            {

                // Display results for each blob found
                for (int i = 0; i < imageProcessed.Body.Results.Count; i++)
                {
                    blob.FoundBlob foundBlob = imageProcessed.Body.Results[i];

                    if (foundBlob.Area > 100) //object detected
                    {

                        Console.WriteLine("Blob detected at (" + foundBlob.MeanX + "," + foundBlob.MeanY + ")");
                        this.visionMode(foundBlob);
                    }
                    else
                    {
                        Console.WriteLine("Blob is too small: area=" + foundBlob.Area);
                    }
                }
            }
        }

        double GetFakeIRDistance()
        {
            double distance = 0;

            //String file = @"C:\Documents and Settings\JL\Desktop\corobotir.htm";

            String robotIP = "128.61.22.166";

            WebClient client = new WebClient();
            String url = @"http://" + robotIP + @":50000/corobotir";

            //using (StreamReader reader = new StreamReader(file))
            using (StreamReader reader = new StreamReader(client.OpenRead(new Uri(url))))
            {
                String line;
                while ((line = reader.ReadLine()) != null)
                {
                    // Looking for <LastFrontRange>25.4</LastFrontRange>
                    // or <th>Front (Meters):</th><td>25.4</td>

                    //String startText = @"<th>Front (Meters):</th><td>";
                    //String endText = "</td>";

                    String startText = @"<LastFrontRange>";
                    String endText = "</LastFrontRange>";

                    int start = line.IndexOf(startText);

                    if (start >= 0)
                    {
                        int end = line.IndexOf(endText, start);

                        if (end >= start)
                        {
                            try
                            {
                                String result = line.Substring(start + startText.Length,
                                    end - start - startText.Length);

                                distance = double.Parse(result);
                            }
                            catch (ArgumentOutOfRangeException aoore)
                            {
                                Console.WriteLine(aoore.Message + System.Environment.NewLine +
                                    aoore.StackTrace);
                            }
                        }
                    }

                }
            }

            return distance;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="lastRotation"></param>
        /// <returns></returns>
        double adjustTurningDistance(double lastRotation)
        {
            double result = Math.Abs(lastRotation) - 2;

            if (result < MIN_TURN_AMOUNT)
            {
                result = MIN_TURN_AMOUNT;
            }

            return result;
        }

        void irMode()
        {

            double irDistance = this.GetFakeIRDistance();

            Console.WriteLine("Distance is " + irDistance);

            if (irDistance <= SWITCH_TO_IR_DISTANCE)
            {

                // We are in IR Sensor range
                //imageTimer.Enabled = false;

                if (irDistance <= .1524)
                {
                    imageTimer.Enabled = false;
                    irTimer.Enabled = false;
                    Console.WriteLine("Robot has arrived at its destination!");
                    return; // We win!
                }
                else
                {
                    stopTimer.Interval = 200;
                    SendDriveForwardMessage(0, 0.2);
                    stopTimer.Interval = 0;

                    //_motionPort.Post(new Drive(new DriveRequest(0.07, MOTOR_POWER)));
                    //driveforward(.25 ft); // We are 1 ft away move slowly
                }

            }
            else
            {
                // Still too far away to use IR
                // Switch to vision mode
                SwitchToVisionMode();
            }
        }

        void visionMode(blob.FoundBlob foundBlob)
        {
            double meanX = (foundBlob.MeanX);
            double irDistance = this.GetFakeIRDistance();

            Console.WriteLine("Distance is " + irDistance);

            if (irDistance <= SWITCH_TO_IR_DISTANCE)
            {
                // Switch to IR mode
                Console.WriteLine("Robot is within IR range!");
                SwitchToIRMode();
            }
            else
            {
                // We need to go off of vision
                double center = 295;
                int buffer = 5;

                Console.WriteLine("Center is " + center + ", Mean x is " + meanX);

                double delta = (center - meanX) / 320;
                double multiplier = 0.45;

                double rotation = delta * multiplier;

                double translation = 0.3;

                Console.WriteLine("Delta is " + delta + " and rotation is " + rotation);

                if ((meanX >= center - buffer) && (meanX <= center + buffer))
                {
                    //_motionPort.Post(new Drive(new DriveRequest(0.15, MOTOR_POWER)));
                    SendDriveForwardMessage(0, translation);

                    // If we moved forward, there was no turn, so reset the turning amount
                    turnAmountInDegrees = INITIAL_TURN_AMOUNT;
                    lastRotation = 0;
                }
                else if (meanX > center)
                {
                    // Turn right
                    Console.WriteLine("Robot is turning right");

                    // Find out whether we were previously turning left. If so, we turned too far
                    // and should reduce the turn amount.
                    if (lastRotation > 0)
                    {
                        turnAmountInDegrees = adjustTurningDistance(lastRotation);
                    }

                    // Turning right means make it negative

                    double radians = turnAmountInDegrees * Math.PI / 180 * -1;
                    //_motionPort.Post(new Turn(new TurnRequest(radians, MOTOR_POWER)));

                    lastRotation = turnAmountInDegrees * -1;

                    SendDriveForwardMessage(rotation - 0.1, translation);
                }
                else
                {
                    // Turn left
                    Console.WriteLine("Robot is turning left");

                    // Find out whether we were previously turning right. If so, we turned too far
                    // and should reduce the turn amount.
                    if (lastRotation < 0)
                    {
                        turnAmountInDegrees = adjustTurningDistance(lastRotation);
                    }

                    double radians = turnAmountInDegrees * Math.PI / 180;
                    //_motionPort.Post(new Turn(new TurnRequest(radians, MOTOR_POWER)));

                    lastRotation = turnAmountInDegrees;

                    SendDriveForwardMessage(rotation + 0.1, translation);
                }
            }

        }

        #region UNUSED
        /// <summary>
        /// Get Handler
        /// </summary>
        /// <param name="get"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetHandler(Get get)
        {
            get.ResponsePort.Post(_state);
            yield break;
        }

        #endregion
    }
}
